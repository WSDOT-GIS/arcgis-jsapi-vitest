import{s as F,b as W,a as _}from"./Error-d97df89f.js";import{t as B,r as E}from"./typedArrayUtil-96f93e5b.js";import{m as A,v as I}from"./Polyline-9d44200b.js";import{r as q,o as L,i as R,s as T}from"./normalizeUtilsCommon-155f1aa2.js";import{b as X,R as j,x as G}from"./Extent-fd3ac910.js";import"./geometry-d89d4a34.js";import{U as C,L as H}from"./request-7c0a9d4c.js";import{c as P,v as K,d as Q}from"./jsonUtils-dd0891e0.js";import{f as V}from"./utils-ada6b2ec.js";async function Y(t,s,c,n){const e=V(t),i=s[0].spatialReference,a={...n,query:{...e.query,f:"json",sr:JSON.stringify(i),target:JSON.stringify({geometryType:P(s[0]),geometries:s}),cutter:JSON.stringify(c)}},o=await C(e.path+"/cut",a),{cutIndexes:p,geometries:g=[]}=o.data;return{cutIndexes:p,geometries:g.map(h=>{const x=K(h);return x.spatialReference=i,x})}}function Z(t){return{geometryType:P(t[0]),geometries:t.map(s=>s.toJSON())}}function tt(t,s,c){const n=Q(s);return t.map(e=>{const i=n.fromJSON(e);return i.spatialReference=c,i})}async function et(t,s,c){const n=typeof t=="string"?H(t):t,e=s[0].spatialReference,i=P(s[0]),a={...c,query:{...n.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(Z(s))}},{data:o}=await C(n.path+"/simplify",a);return tt(o.geometries,i,e)}const D=F.getLogger("esri.geometry.support.normalizeUtils");function st(t){return t.type==="polygon"}function nt(t){return t[0].type==="polygon"}function ot(t){return t[0].type==="polyline"}function rt(t,s){if(!(t instanceof A||t instanceof I)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw D.error(e),new _(e)}const c=L(t),n=[];for(const e of c){const i=[];n.push(i),i.push([e[0][0],e[0][1]]);for(let a=0;a<e.length-1;a++){const o=e[a][0],p=e[a][1],g=e[a+1][0],h=e[a+1][1],x=Math.sqrt((g-o)*(g-o)+(h-p)*(h-p)),l=(h-p)/x,y=(g-o)/x,u=x/s;if(u>1){for(let S=1;S<=u-1;S++){const N=S*s,r=y*N+o,f=l*N+p;i.push([r,f])}const $=(x+Math.floor(u-1)*s)/2,v=y*$+o,M=l*$+p;i.push([v,M])}i.push([g,h])}}return st(t)?new I({rings:n,spatialReference:t.spatialReference}):new A({paths:n,spatialReference:t.spatialReference})}function z(t,s,c){if(s){const n=rt(t,1e6);t=G(n,!0)}return c&&(t=T(t,c)),t}function k(t,s,c){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<c){const e=R(n,c);t[0]=n+e*(-2*c)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<c){const e=R(n,c);t=t.clone().offset(e*(-2*c),0)}}return t}function it(t,s){let c=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],i=s.geometries[n],a=L(i);for(let o=0;o<a.length;o++){const p=a[o];p.some(g=>{if(g[0]<180)return!0;{let h=0;for(let l=0;l<p.length;l++){const y=p[l][0];h=y>h?y:h}h=Number(h.toFixed(9));const x=-360*R(h,180);for(let l=0;l<p.length;l++){const y=i.getPoint(o,l);i.setPoint(o,l,y.clone().offset(x,0))}return!0}})}if(e===c){if(nt(t))for(const o of L(i))t[e]=t[e].addRing(o);else if(ot(t))for(const o of L(i))t[e]=t[e].addPath(o)}else c=e,t[e]=i}return t}async function ft(t,s,c){if(!Array.isArray(t))return ft([t],s);s&&typeof s!="string"&&D.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??W.geometryServiceUrl;let e,i,a,o,p,g,h,x,l=0;const y=[],u=[];for(const r of t)if(B(r))u.push(r);else if(e||(e=r.spatialReference,i=X(e),a=e.isWebMercator,g=a?102100:4326,o=q[g].maxX,p=q[g].minX,h=q[g].plus180Line,x=q[g].minus180Line),i)if(r.type==="mesh")u.push(r);else if(r.type==="point")u.push(k(r.clone(),o,p));else if(r.type==="multipoint"){const f=r.clone();f.points=f.points.map(m=>k(m,o,p)),u.push(f)}else if(r.type==="extent"){const f=r.clone()._normalize(!1,!1,i);u.push(f.rings?new I(f):f)}else if(r.extent){const f=r.extent,m=R(f.xmin,p)*(2*o);let d=m===0?r.clone():T(r.clone(),m);f.offset(m,0),f.intersects(h)&&f.xmax!==o?(l=f.xmax>l?f.xmax:l,d=z(d,a),y.push(d),u.push("cut")):f.intersects(x)&&f.xmin!==p?(l=f.xmax*(2*o)>l?f.xmax*(2*o):l,d=z(d,a,360),y.push(d),u.push("cut")):u.push(d)}else u.push(r.clone());else u.push(r);let $=R(l,o),v=-90;const M=$,S=new A;for(;$>0;){const r=360*$-180;S.addPath([[r,v],[r,-1*v]]),v*=-1,$--}if(y.length>0&&M>0){const r=it(y,await Y(n,y,S,c)),f=[],m=[];for(let w=0;w<u.length;w++){const J=u[w];if(J!=="cut")m.push(J);else{const b=r.shift(),O=t[w];E(O)&&O.type==="polygon"&&O.rings&&O.rings.length>1&&b.rings.length>=O.rings.length?(f.push(b),m.push("simplify")):m.push(a?j(b):b)}}if(!f.length)return m;const d=await et(n,f,c),U=[];for(let w=0;w<m.length;w++){const J=m[w];J!=="simplify"?U.push(J):U.push(a?j(d.shift()):d.shift())}return U}const N=[];for(let r=0;r<u.length;r++){const f=u[r];if(f!=="cut")N.push(f);else{const m=y.shift();N.push(a===!0?j(m):m)}}return N}function xt(t,s){const c=X(s);if(c){const[n,e]=c.valid,i=e-n;if(t<n)for(;t<n;)t+=i;if(t>e)for(;t>e;)t-=i}return t}export{xt as U,tt as o,ft as v};
