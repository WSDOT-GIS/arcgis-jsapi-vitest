import{s as $t,a as Lt}from"./cast-73cfc253.js";import{r as $,t as H,e as ft,I as It}from"./typedArrayUtil-96f93e5b.js";import{e as O,y as J,a as jt,l as Et}from"./JSONSupport-ed372989.js";import{a as Nt,s as Z}from"./Error-d97df89f.js";import{p as Gt,h as nt}from"./string-feb899cf.js";import{s as gt}from"./pixelRangeUtils-03719dd8.js";import"./geometry-d89d4a34.js";import{m as qt}from"./mathUtils-b3bee9e7.js";import{f as Ot}from"./promiseUtils-ac1bd36f.js";import{b as Wt,a as zt}from"./Extent-fd3ac910.js";let yt=class{constructor(e=null,n=null,l=null){this.minValue=e,this.maxValue=n,this.noDataValue=l}};var tt;let q=tt=class extends Et{static createEmptyBand(t,e){return new(tt.getPixelArrayConstructor(t))(e)}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){var t;return(t=this.pixels)==null?void 0:t.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new Nt("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new yt)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(n=>this._calculateBandStatistics(n,this.mask));const t=this.mask;let e=0;if($(t))for(let n=0;n<t.length;n++)t[n]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,n]=gt(t),l=this.pixels,a=this.width*this.height,s=l.length;let r,h,c;const o=[];for(let i=0;i<s;i++){c=tt.createEmptyBand(t,a),r=l[i];for(let u=0;u<a;u++)h=r[u],c[u]=h>n?n:h<e?e:h;o.push(c)}this.pixels=o,this.pixelType=t}extractBands(t){const{pixels:e,statistics:n}=this;if(H(t)||t.length===0||!e||e.length===0)return this;const l=e.length,a=t.some(r=>r>=e.length),s=l===t.length&&!t.some((r,h)=>r!==h);return a||s?this:new tt({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:t.map(r=>e[r]),statistics:n&&t.map(r=>n[r])})}clone(){const t=new tt({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;$(this.mask)&&(this.mask instanceof Uint8Array?t.mask=new Uint8Array(this.mask):t.mask=this.mask.slice(0));const n=tt.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const l=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=l?this.pixels[e].slice(0,this.pixels[e].length):new n(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=Gt(this.statistics[e]);return t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:n,pixels:l}=this;if(!t||!l||!l.length)return void Z.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let a,s,r,h;a=s=r=l[0],l.length>=3?(s=l[1],r=l[2]):l.length===2&&(s=l[1]);const c=new Uint32Array(t),o=this.width*this.height;if(a.length===o)if($(e)&&e.length===o)if(n)for(h=0;h<o;h++){const i=e[h];if(i){const u=i/255;c[h]=i<<24|r[h]*u<<16|s[h]*u<<8|a[h]*u}}else for(h=0;h<o;h++)e[h]&&(c[h]=255<<24|r[h]<<16|s[h]<<8|a[h]);else for(h=0;h<o;h++)c[h]=255<<24|r[h]<<16|s[h]<<8|a[h];else Z.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:n,statistics:l}=this;if(!t||!e||!e.length)return void Z.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const a=this.pixelType;let s=1,r=0,h=1;if(l&&l.length>0){for(const m of l)if(m.minValue!=null&&(r=Math.min(r,m.minValue)),m.maxValue!=null&&m.minValue!=null){const g=m.maxValue-m.minValue;h=Math.max(h,g)}s=255/h}else{let m=255;a==="s8"?(r=-128,m=127):a==="u16"?m=65535:a==="s16"?(r=-32768,m=32767):a==="u32"?m=4294967295:a==="s32"?(r=-2147483648,m=2147483647):a==="f32"?(r=-34e38,m=34e38):a==="f64"&&(r=-Number.MAX_VALUE,m=Number.MAX_VALUE),s=255/(m-r)}const c=new Uint32Array(t),o=this.width*this.height;let i,u,p,f,d;if(i=u=p=e[0],i.length!==o)return Z.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(u=e[1],e.length>=3&&(p=e[2]),$(n)&&n.length===o)for(f=0;f<o;f++)n[f]&&(c[f]=255<<24|(p[f]-r)*s<<16|(u[f]-r)*s<<8|(i[f]-r)*s);else for(f=0;f<o;f++)c[f]=255<<24|(p[f]-r)*s<<16|(u[f]-r)*s<<8|(i[f]-r)*s;else if($(n)&&n.length===o)for(f=0;f<o;f++)d=(i[f]-r)*s,n[f]&&(c[f]=255<<24|d<<16|d<<8|d);else for(f=0;f<o;f++)d=(i[f]-r)*s,c[f]=255<<24|d<<16|d<<8|d}_fillFrom32Bit(t){const{pixels:e,mask:n}=this;if(!t||!e||!e.length)return Z.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let l,a,s,r;l=a=s=e[0],e.length>=3?(a=e[1],s=e[2]):e.length===2&&(a=e[1]);const h=this.width*this.height;if(l.length!==h)return Z.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let c=0;if($(n)&&n.length===h)for(r=0;r<h;r++)t[c++]=l[r],t[c++]=a[r],t[c++]=s[r],t[c++]=1&n[r];else for(r=0;r<h;r++)t[c++]=l[r],t[c++]=a[r],t[c++]=s[r],t[c++]=1}_calculateBandStatistics(t,e){let n=1/0,l=-1/0;const a=t.length;let s,r=0;if($(e))for(s=0;s<a;s++)e[s]&&(r=t[s],n=r<n?r:n,l=r>l?r:l);else for(s=0;s<a;s++)r=t[s],n=r<n?r:n,l=r>l?r:l;return new yt(n,l)}};O([J({json:{write:!0}})],q.prototype,"width",void 0),O([J({json:{write:!0}})],q.prototype,"height",void 0),O([J({json:{write:!0}})],q.prototype,"pixelType",void 0),O([$t("pixelType")],q.prototype,"castPixelType",null),O([J({json:{write:!0}})],q.prototype,"validPixelCount",void 0),O([J({json:{write:!0}})],q.prototype,"mask",void 0),O([J({json:{write:!0}})],q.prototype,"maskIsAlpha",void 0),O([J({json:{write:!0}})],q.prototype,"pixels",void 0),O([J({json:{write:!0}})],q.prototype,"statistics",void 0),O([J({json:{write:!0}})],q.prototype,"depthCount",void 0),O([J({json:{write:!0}})],q.prototype,"noDataValues",void 0),O([J({json:{write:!0}})],q.prototype,"bandMasks",void 0),q=tt=O([jt("esri.layers.support.PixelBlock")],q);const D=q;var kt,Mt;(function(t){t[t.matchAny=0]="matchAny",t[t.matchAll=1]="matchAll"})(kt||(kt={})),function(t){t[t.bestMatch=0]="bestMatch",t[t.fail=1]="fail"}(Mt||(Mt={}));const Ue=6;function L(t){return $(t)&&t.declaredClass==="esri.layers.support.PixelBlock"&&t.pixels&&t.pixels.length>0}function Te(t,e){if(!(e!=null&&e.length)||!L(t))return t;const n=t.pixels.length;return e&&e.some(l=>l>=n)||n===1&&e.length===1&&e[0]===0?t:n!==e.length||e.some((l,a)=>l!==a)?new D({pixelType:t.pixelType,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:e.map(l=>t.pixels[l]),statistics:t.statistics&&e.map(l=>t.statistics[l])}):t}function Ie(t){if(!(t!=null&&t.length)||t.some(i=>!L(i)))return null;if(t.length===1)return $(t[0])?t[0].clone():null;const e=t,{width:n,height:l,pixelType:a}=e[0];if(e.some(i=>i.width!==n||i.height!==l))return null;const s=e.map(({mask:i})=>i).filter(i=>i!=null);let r=null;s.length&&(r=new Uint8Array(n*l),r.set(s[0]),s.length>1&&St(s.slice(1),r));const h=[];e.forEach(({pixels:i})=>h.push(...i));const c=e.map(({statistics:i})=>i).filter(i=>i==null?void 0:i.length),o=[];return c.forEach(i=>o.push(...i)),new D({pixelType:a,width:n,height:l,mask:r,pixels:h,statistics:o.length?o:null})}function Be(t){if(!t)return;const e=t.colormap;if(!e||e.length===0)return;const n=e.sort((u,p)=>u[0]-p[0]);let l=0;n[0][0]<0&&(l=n[0][0]);const a=Math.max(256,n[n.length-1][0]-l+1),s=new Uint8Array(4*a),r=[];let h,c=0,o=0;const i=n[0].length===5;if(a>65536)return n.forEach(u=>{r[u[0]-l]=i?u.slice(1):u.slice(1).concat([255])}),{indexed2DColormap:r,offset:l,alphaSpecified:i};if(t.fillUnspecified)for(h=n[o],c=h[0]-l;c<a;c++)s[4*c]=h[1],s[4*c+1]=h[2],s[4*c+2]=h[3],s[4*c+3]=i?h[4]:255,c===h[0]-l&&(h=o===n.length-1?h:n[++o]);else for(c=0;c<n.length;c++)h=n[c],o=4*(h[0]-l),s[o]=h[1],s[o+1]=h[2],s[o+2]=h[3],s[o+3]=i?h[4]:255;return{indexedColormap:s,offset:l,alphaSpecified:i}}function Se(t,e){if(!L(t)||!e||!e.indexedColormap&&!e.indexed2DColormap)return t;const n=t.clone(),l=n.pixels;let a=n.mask;const s=n.width*n.height;if(l.length!==1)return t;const{indexedColormap:r,indexed2DColormap:h,offset:c,alphaSpecified:o}=e;let i=0;const u=l[0],p=new Uint8Array(u.length),f=new Uint8Array(u.length),d=new Uint8Array(u.length);let m,g=0;if(r){const y=r.length-1;if($(a))for(i=0;i<s;i++)a[i]&&(g=4*(u[i]-c),g<c||g>y?a[i]=0:(p[i]=r[g],f[i]=r[g+1],d[i]=r[g+2],a[i]=r[g+3]));else{for(a=new Uint8Array(s),i=0;i<s;i++)g=4*(u[i]-c),g<c||g>y?a[i]=0:(p[i]=r[g],f[i]=r[g+1],d[i]=r[g+2],a[i]=r[g+3]);n.mask=a}}else if(h)if($(a))for(i=0;i<s;i++)a[i]&&(m=h[u[i]],p[i]=m[0],f[i]=m[1],d[i]=m[2],a[i]=m[3]);else{for(a=new Uint8Array(s),i=0;i<s;i++)m=h[u[i]],p[i]=m[0],f[i]=m[1],d[i]=m[2],a[i]=m[3];n.mask=a}return n.pixels=[p,f,d],n.statistics=null,n.pixelType="u8",n.maskIsAlpha=o,n}function Ce(t,e){if(!L(t))return null;const{pixels:n,mask:l}=t,a=n.length;let s=e.lut;const{offset:r}=e;s&&s[0].length===1&&(s=n.map(()=>s));const h=[],c=e.outputPixelType||"u8";for(let i=0;i<a;i++){const u=Bt(n[i],l,s[i],r||0,c);h.push(u)}const o=new D({width:t.width,height:t.height,pixels:h,mask:l,pixelType:c});return o.updateStatistics(),o}function Bt(t,e,n,l,a){const s=t.length,r=D.createEmptyBand(a,s);if(e)for(let h=0;h<s;h++)e[h]&&(r[h]=n[t[h]-l]);else for(let h=0;h<s;h++)r[h]=n[t[h]-l];return r}function Fe(t,e){if(!L(t))return null;const n=t.clone(),{pixels:l}=n,a=n.width*n.height,s=e.length,r=Math.floor(s/2),h=e[Math.floor(r)],c=l[0];let o,i,u,p,f,d,m=!1;const g=new Uint8Array(a),y=new Uint8Array(a),M=new Uint8Array(a);let k=n.mask;const w=e[0].mappedColor.length===4;for(k||(k=new Uint8Array(a),k.fill(w?255:1),n.mask=k),f=0;f<a;f++)if(k[f]){for(o=c[f],m=!1,d=r,i=h,u=0,p=s-1;p-u>1;){if(o===i.value){m=!0;break}o>i.value?u=d:p=d,d=Math.floor((u+p)/2),i=e[Math.floor(d)]}m||(o===e[u].value?(i=e[u],m=!0):o===e[p].value?(i=e[p],m=!0):o<e[u].value?(m=!1,i=null):o>e[u].value&&(o<e[p].value?(i=e[u],m=!0):p===s-1?(m=!1,i=null):(i=e[p],m=!0))),m?(g[f]=i.mappedColor[0],y[f]=i.mappedColor[1],M[f]=i.mappedColor[2],k[f]=i.mappedColor[3]):g[f]=y[f]=M[f]=k[f]=0}return n.pixels=[g,y,M],n.mask=k,n.pixelType="u8",n.maskIsAlpha=w,n}function _e(t,e){if(!L(t))return null;const{width:n,height:l}=t,{inputRanges:a,outputValues:s,outputPixelType:r,noDataRanges:h,allowUnmatched:c,isLastInputRangeInclusive:o}=e,i=t.pixels[0],u=D.createEmptyBand(r,i.length),p=t.mask,f=new Uint8Array(n*l);p?f.set(p):f.fill(255);const d=t.pixelType.startsWith("f")?1e-6:0,m=a.map(k=>k-d);m[0]=a[0],m[m.length-1]=a[a.length-1]+(o?1e-6:0);const g=a.length/2,[y,M]=gt(r);for(let k=0;k<l;k++)for(let w=0;w<n;w++){const x=k*n+w;if(f[x]){const A=i[x];let b=!1;for(let v=g-1;v>=0;v--)if(A===m[2*v]||A>m[2*v]&&A<m[2*v+1]){u[x]=s[v],b=!0;break}b||(c?u[x]=A>M?M:A<y?y:A:f[x]=0)}}if(h!=null&&h.length)for(let k=0;k<l;k++)for(let w=0;w<n;w++){const x=k*n+w;if(!p||p[x]){const A=i[x];for(let b=0;b<g;b+=2)if(A>=h[b]&&A<=h[b+1]){u[x]=0,f[x]=0;break}}}return new D({width:n,height:l,pixelType:r,pixels:[u],mask:f})}function At(t,e,n,l){const a=n!=null&&n.length>=2?new Set(n):null,s=(n==null?void 0:n.length)===1?n[0]:null,r=!!(e!=null&&e.length);for(let h=0;h<t.length;h++)if(l[h]){const c=t[h];if(r){let o=!1;for(let i=0;i<e.length;i+=2)if(c>=e[i]&&c<=e[i+1]){o=!0;break}o||(l[h]=0)}l[h]&&(c===s||a!=null&&a.has(c))&&(l[h]=0)}}function bt(t,e){const n=t[0].length;for(let l=0;l<n;l++)if(e[l]){let a=!1;for(let s=0;s<t.length;s++)if(t[s][l]){a=!0;break}a||(e[l]=0)}}function St(t,e){const n=t[0].length;for(let l=0;l<n;l++)if(e[l]){let a=!1;for(let s=0;s<t.length;s++)if(t[s][l]===0){a=!0;break}a&&(e[l]=0)}}function Ve(t,e){if(!L(t))return null;const{width:n,height:l,pixels:a}=t,s=n*l,r=new Uint8Array(s);t.mask?r.set(t.mask):r.fill(255);const h=a.length,{includedRanges:c,noDataValues:o,outputPixelType:i,matchAll:u,lookups:p}=e;if(p){const f=[];for(let d=0;d<h;d++){const m=p[d],g=Bt(a[d],r,m.lut,m.offset||0,"u8");f.push(g)}f.length===1?r.set(f[0]):u?bt(f,r):St(f,r)}else if(u){const f=[];for(let d=0;d<h;d++){const m=new Uint8Array(s);m.set(r),At(a[d],c==null?void 0:c.slice(2*d,2*d+2),o==null?void 0:o[d],m),f.push(m)}f.length===1?r.set(f[0]):bt(f,r)}else for(let f=0;f<h;f++)At(a[f],c==null?void 0:c.slice(2*f,2*f+2),o==null?void 0:o[f],r);return new D({width:n,height:l,pixelType:i,pixels:a,mask:r})}function De(t){const{srcPixelType:e,inputRanges:n,outputValues:l,allowUnmatched:a,noDataRanges:s,isLastInputRangeInclusive:r,outputPixelType:h}=t;if(e!=="u8"&&e!=="s8"&&e!=="u16"&&e!=="s16")return null;const c=e.includes("16")?65536:256,o=e.includes("s")?-c/2:0,i=D.createEmptyBand(h,c),u=new Uint8Array(c);a&&u.fill(255);const[p,f]=gt(h);if(n!=null&&n.length&&(l!=null&&l.length)){const m=n.map(g=>g-1e-6);m[0]=n[0],r&&(m[m.length-1]=n[n.length-1]);for(let g=0;g<m.length;g++){const y=l[g]>f?f:l[g]<p?p:l[g],M=Math.ceil(m[2*g]-o),k=Math.floor(m[2*g+1]-o);for(let w=M;w<=k;w++)i[w]=y,u[w]=255}}if(s!=null&&s.length)for(let d=0;d<s.length;d++){const m=Math.ceil(s[2*d]-o),g=Math.floor(s[2*d+1]-o);for(let y=m;y<=g;y++)u[y]=0}return{lut:i,offset:o,mask:u}}function Re(t,e,n){if(t!=="u8"&&t!=="s8"&&t!=="u16"&&t!=="s16")return null;const l=t.includes("16")?65536:256,a=t.includes("s")?-l/2:0,s=new Uint8Array(l);if(e)for(let r=0;r<e.length;r++){const h=Math.ceil(e[2*r]-a),c=Math.floor(e[2*r+1]-a);for(let o=h;o<=c;o++)s[o]=255}else s.fill(255);if(n)for(let r=0;r<n.length;r++)s[n[r]-a]=0;return{lut:s,offset:a}}function Jt(t,e,n,l,a,s,r,h){return{xmin:a<=n*t?0:a<n*t+t?a-n*t:t,ymin:s<=l*e?0:s<l*e+e?s-l*e:e,xmax:a+r<=n*t?0:a+r<n*t+t?a+r-n*t:t,ymax:s+h<=l*e?0:s+h<l*e+e?s+h-l*e:e}}function $e(t,e){if(!t||t.length===0)return null;const n=t.find(d=>d.pixelBlock);if(!n||H(n.pixelBlock))return null;const l=(n.extent.xmax-n.extent.xmin)/n.pixelBlock.width,a=(n.extent.ymax-n.extent.ymin)/n.pixelBlock.height,s=.01*Math.min(l,a),r=t.sort((d,m)=>Math.abs(d.extent.ymax-m.extent.ymax)>s?m.extent.ymax-d.extent.ymax:Math.abs(d.extent.xmin-m.extent.xmin)>s?d.extent.xmin-m.extent.xmin:0),h=Math.min.apply(null,r.map(d=>d.extent.xmin)),c=Math.min.apply(null,r.map(d=>d.extent.ymin)),o=Math.max.apply(null,r.map(d=>d.extent.xmax)),i=Math.max.apply(null,r.map(d=>d.extent.ymax)),u={x:Math.round((e.xmin-h)/l),y:Math.round((i-e.ymax)/a)},p={width:Math.round((o-h)/l),height:Math.round((i-c)/a)},f={width:Math.round((e.xmax-e.xmin)/l),height:Math.round((e.ymax-e.ymin)/a)};return Math.round(p.width/n.pixelBlock.width)*Math.round(p.height/n.pixelBlock.height)!==r.length||u.x<0||u.y<0||p.width<f.width||p.height<f.height?null:{extent:e,pixelBlock:Xt(r.map(d=>d.pixelBlock),p,{clipOffset:u,clipSize:f})}}function pt(t,e,n,l,a,s){const{width:r,height:h}=n.block,{x:c,y:o}=n.offset,{width:i,height:u}=n.mosaic,p=Jt(r,h,l,a,c,o,i,u);let f=0,d=0;if(s){const m=s.hasGCSSShiftTransform?360:s.halfWorldWidth??0,g=r*s.resolutionX,y=s.startX+l*g;y<m&&y+g>m?d=s.rightPadding:y>=m&&(f=s.leftMargin-s.rightPadding,d=0)}if(p.xmax-=d,typeof e!="number")for(let m=p.ymin;m<p.ymax;m++){const g=(a*h+m-o)*i+(l*r-c)+f,y=m*r;for(let M=p.xmin;M<p.xmax;M++)t[g+M]=e[y+M]}else for(let m=p.ymin;m<p.ymax;m++){const g=(a*h+m-o)*i+(l*r-c)+f;for(let y=p.xmin;y<p.xmax;y++)t[g+y]=e}}function Xt(t,e,n={}){const{clipOffset:l,clipSize:a,alignmentInfo:s,blockWidths:r}=n;if(r)return Ht(t,e,{blockWidths:r});const h=t.find(b=>L(b));if(H(h))return null;const c=a?a.width:e.width,o=a?a.height:e.height,i=h.width,u=h.height,p=e.width/i,f=e.height/u,d={offset:l||{x:0,y:0},mosaic:a||e,block:{width:i,height:u}},m=h.pixelType,g=D.getPixelArrayConstructor(m),y=h.pixels.length,M=[];let k,w;for(let b=0;b<y;b++){w=new g(c*o);for(let v=0;v<f;v++)for(let P=0;P<p;P++){const U=t[v*p+P];L(U)&&(k=U.pixels[b],pt(w,k,d,P,v,s))}M.push(w)}let x;if(t.some(b=>H(b)||$(b.mask)&&b.mask.length>0)){x=new Uint8Array(c*o);for(let b=0;b<f;b++)for(let v=0;v<p;v++){const P=t[b*p+v],U=$(P)?P.mask:null;$(U)?pt(x,U,d,v,b,s):pt(x,P?1:0,d,v,b,s)}}const A=new D({width:c,height:o,pixels:M,pixelType:m,mask:x});return A.updateStatistics(),A}function Ht(t,e,n){const l=t.find(f=>$(f));if(H(l))return null;const a=t.some(f=>!$(f)||!!f.mask),{width:s,height:r}=e,h=a?new Uint8Array(s*r):null,{blockWidths:c}=n,o=[],i=l.getPlaneCount(),u=D.getPixelArrayConstructor(l.pixelType);if(a)for(let f=0,d=0;f<t.length;d+=c[f],f++){const m=t[f];if(!L(m))continue;const g=ft(m.mask);for(let y=0;y<r;y++)for(let M=0;M<c[f];M++)h[y*s+M+d]=g==null?255:g[y*m.width+M]}for(let f=0;f<i;f++){const d=new u(s*r);for(let m=0,g=0;m<t.length;g+=c[m],m++){const y=t[m];if(!L(y))continue;const M=y.pixels[f];if(M!=null)for(let k=0;k<r;k++)for(let w=0;w<c[m];w++)d[k*s+w+g]=M[k*y.width+w]}o.push(d)}const p=new D({width:s,height:r,mask:h,pixels:o,pixelType:l.pixelType});return p.updateStatistics(),p}function Le(t,e,n){if(!L(t))return null;const{width:l,height:a}=t,s=e.x,r=e.y,h=n.width+s,c=n.height+r;if(s<0||r<0||h>l||c>a||s===0&&r===0&&h===l&&c===a)return t;t.mask||(t.mask=new Uint8Array(l*a));const o=t.mask;for(let i=0;i<a;i++){const u=i*l;for(let p=0;p<l;p++)o[u+p]=i<r||i>=c||p<s||p>=h?0:1}return t.updateStatistics(),t}function Kt(t){if(!L(t))return null;const e=t.clone(),{width:n,height:l,pixels:a}=t,s=a[0],r=e.pixels[0],h=ft(t.mask);for(let c=2;c<l-1;c++){const o=new Map;for(let u=c-2;u<c+2;u++)for(let p=0;p<4;p++){const f=u*n+p;rt(o,s[f],h?h[f]:1)}r[c*n]=vt(o),r[c*n+1]=r[c*n+2]=r[c*n];let i=3;for(;i<n-1;i++){let u=(c-2)*n+i+1;rt(o,s[u],h?h[u]:1),u=(c-1)*n+i+1,rt(o,s[u],h?h[u]:1),u=c*n+i+1,rt(o,s[u],h?h[u]:1),u=(c+1)*n+i+1,rt(o,s[u],h?h[u]:1),u=(c-2)*n+i-3,at(o,s[u],h?h[u]:1),u=(c-1)*n+i-3,at(o,s[u],h?h[u]:1),u=c*n+i-3,at(o,s[u],h?h[u]:1),u=(c+1)*n+i-3,at(o,s[u],h?h[u]:1),r[c*n+i]=vt(o)}r[c*n+i+1]=r[c*n+i]}for(let c=0;c<n;c++)r[c]=r[n+c]=r[2*n+c],r[(l-1)*n+c]=r[(l-2)*n+c];return e.updateStatistics(),e}function vt(t){if(t.size===0)return 0;let e=0,n=-1,l=0;const a=t.keys();let s=a.next();for(;!s.done;)l=t.get(s.value),l>e&&(n=s.value,e=l),s=a.next();return n}function at(t,e,n){if(n===0)return;const l=t.get(e);l===1?t.delete(e):t.set(e,l-1)}function rt(t,e,n){n!==0&&t.set(e,t.has(e)?t.get(e)+1:1)}function Qt(t,e,n){let{x:l,y:a}=e;const{width:s,height:r}=n;if(l===0&&a===0&&r===t.height&&s===t.width)return t;const{width:h,height:c}=t,o=Math.max(0,a),i=Math.max(0,l),u=Math.min(l+s,h),p=Math.min(a+r,c);if(u<0||p<0||!L(t))return null;l=Math.max(0,-l),a=Math.max(0,-a);const{pixels:f}=t,d=s*r,m=f.length,g=[];for(let w=0;w<m;w++){const x=f[w],A=D.createEmptyBand(t.pixelType,d);for(let b=o;b<p;b++){const v=b*h;let P=(b+a-o)*s+l;for(let U=i;U<u;U++)A[P++]=x[v+U]}g.push(A)}const y=new Uint8Array(d),M=ft(t.mask);for(let w=o;w<p;w++){const x=w*h;let A=(w+a-o)*s+l;for(let b=i;b<u;b++)y[A++]=M?M[x+b]:1}const k=new D({width:n.width,height:n.height,pixelType:t.pixelType,pixels:g,mask:y});return k.updateStatistics(),k}function Yt(t,e=!0){if(!L(t))return null;const{pixels:n,width:l,height:a,mask:s,pixelType:r}=t,h=[],c=Math.round(l/2),o=Math.round(a/2),i=a-1,u=l-1;for(let f=0;f<n.length;f++){const d=n[f],m=D.createEmptyBand(r,c*o);let g=0;for(let y=0;y<a;y+=2)for(let M=0;M<l;M+=2){const k=d[y*l+M];if(e){const w=M===u?k:d[y*l+M+1],x=y===i?k:d[y*l+M+l],A=M===u?x:y===i?w:d[y*l+M+l+1];m[g++]=(k+w+x+A)/4}else m[g++]=k}h.push(m)}let p=null;if($(s)){p=new Uint8Array(c*o);let f=0;for(let d=0;d<a;d+=2)for(let m=0;m<l;m+=2){const g=s[d*l+m];if(e){const y=m===u?g:s[d*l+m+1],M=d===i?g:s[d*l+m+l],k=m===u?M:d===i?y:s[d*l+m+l+1];p[f++]=g*y*M*k?1:0}else p[f++]=g}}return new D({width:c,height:o,pixelType:r,pixels:h,mask:p})}function je(t,e,n){if(!L(t))return null;const{width:l,height:a}=e;let{width:s,height:r}=t;const h=new Map,c={x:0,y:0},o=n==null?1:1+n;let i=t;for(let u=0;u<o;u++){const p=Math.ceil(s/l),f=Math.ceil(r/a);for(let d=0;d<f;d++){c.y=d*a;for(let m=0;m<p;m++){c.x=m*l;const g=Qt(i,c,e);h.set(`${u}/${d}/${m}`,g)}}u<o-1&&(i=Yt(i)),s=Math.round(s/2),r=Math.round(r/2)}return h}function Ct(t,e,n,l,a=0){const{width:s,height:r}=t,{width:h,height:c}=e,o=l.cols,i=l.rows,u=Math.ceil(h/o-.1/o),p=Math.ceil(c/i-.1/i);let f,d,m,g,y,M,k;const w=u*o,x=w*p*i,A=new Float32Array(x),b=new Float32Array(x),v=new Uint32Array(x),P=new Uint32Array(x);let U,C,B=0;for(let S=0;S<p;S++)for(let _=0;_<u;_++){f=12*(S*u+_),d=n[f],m=n[f+1],g=n[f+2],y=n[f+3],M=n[f+4],k=n[f+5];for(let I=0;I<i;I++){B=(S*i+I)*w+_*o,C=(I+.5)/i;for(let T=0;T<I;T++)U=(T+.5)/o,A[B+T]=(d*U+m*C+g)*s+a,b[B+T]=(y*U+M*C+k)*r+a,v[B+T]=Math.floor(A[B+T]),P[B+T]=Math.floor(b[B+T])}f+=6,d=n[f],m=n[f+1],g=n[f+2],y=n[f+3],M=n[f+4],k=n[f+5];for(let I=0;I<i;I++){B=(S*i+I)*w+_*o,C=(I+.5)/i;for(let T=I;T<o;T++)U=(T+.5)/o,A[B+T]=(d*U+m*C+g)*s+a,b[B+T]=(y*U+M*C+k)*r+a,v[B+T]=Math.floor(A[B+T]),P[B+T]=Math.floor(b[B+T])}}return{offsets_x:A,offsets_y:b,offsets_xi:v,offsets_yi:P,gridWidth:w}}function Ee(t,e){const{coefficients:n,spacing:l}=e,{offsets_x:a,offsets_y:s,gridWidth:r}=Ct(t,t,n,{rows:l[0],cols:l[1]}),{width:h,height:c}=t,o=new Float32Array(h*c),i=180/Math.PI;for(let u=0;u<c;u++)for(let p=0;p<h;p++){const f=u*r+p,d=u===0?f:f-r,m=u===c-1?f:f+r,g=a[d]-a[m],y=s[m]-s[d];if(isNaN(g)||isNaN(y))o[u*h+p]=90;else{let M=Math.atan2(y,g)*i;M=(360+M)%360,o[u*h+p]=M}}return o}function Ne(t,e,n,l,a="nearest"){if(!L(t))return null;a==="majority"&&(t=Kt(t));const{pixels:s,mask:r,pixelType:h}=t,c=t.width,o=t.height,i=D.getPixelArrayConstructor(h),u=s.length,{width:p,height:f}=e;let d=!1;for(let P=0;P<n.length;P+=3)n[P]===-1&&n[P+1]===-1&&n[P+2]===-1&&(d=!0);const{offsets_x:m,offsets_y:g,offsets_xi:y,offsets_yi:M,gridWidth:k}=Ct({width:c,height:o},e,n,l,a==="majority"?.5:0);let w;const x=(P,U,C)=>{const B=P instanceof Float32Array||P instanceof Float64Array?0:.5;for(let S=0;S<f;S++){w=S*k;for(let _=0;_<p;_++){if(m[w]<0||g[w]<0)P[S*p+_]=0;else if(C)P[S*p+_]=U[y[w]+M[w]*c];else{const I=Math.floor(m[w]),T=Math.floor(g[w]),F=Math.ceil(m[w]),V=Math.ceil(g[w]),N=m[w]-I,z=g[w]-T;if(!r||r[I+T*c]&&r[I+T*c]&&r[I+V*c]&&r[F+V*c]){const G=(1-N)*U[I+T*c]+N*U[F+T*c],W=(1-N)*U[I+V*c]+N*U[F+V*c];P[S*p+_]=(1-z)*G+z*W+B}else P[S*p+_]=U[y[w]+M[w]*c]}w++}}},A=[];let b;for(let P=0;P<u;P++)b=new i(p*f),x(b,s[P],a==="nearest"||a==="majority"),A.push(b);const v=new D({width:p,height:f,pixelType:h,pixels:A});if($(r))v.mask=new Uint8Array(p*f),x(v.mask,r,!0);else if(d){v.mask=new Uint8Array(p*f);for(let P=0;P<p*f;P++)v.mask[P]=m[P]<0||g[P]<0?0:1}return v.updateStatistics(),v}const et=new Map;et.set("meter-per-second",1),et.set("kilometer-per-hour",.277778),et.set("knots",.514444),et.set("feet-per-second",.3048),et.set("mile-per-hour",.44704);const dt=180/Math.PI,xt=5,ct=new Lt({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function wt(t,e){return et.get(t)/et.get(e)||1}function Ft(t){return(450-t)%360}function _t(t,e="geographic"){const[n,l]=t,a=Math.sqrt(n*n+l*l);let s=Math.atan2(l,n)*dt;return s=(360+s)%360,e==="geographic"&&(s=Ft(s)),[a,s]}function Vt(t,e="geographic"){let n=t[1];e==="geographic"&&(n=Ft(n)),n%=360;const l=t[0];return[l*Math.cos(n/dt),l*Math.sin(n/dt)]}function Ge(t,e,n,l="geographic"){if(!L(t)||H(n))return t;const a=e==="vector-magdir"?t.clone():ft(Pt(t,e)),s=a.pixels[1];for(let r=0;r<s.length;r++)s[r]=l==="geographic"?(s[r]+n[r]+270)%360:(s[r]+360-n[r])%360;return e==="vector-magdir"?a:Pt(a,"vector-magdir")}function Pt(t,e,n="geographic",l=1){if(!L(t))return t;const{pixels:a,width:s,height:r}=t,h=s*r,c=a[0],o=a[1],i=t.pixelType.startsWith("f")?t.pixelType:"f32",u=D.createEmptyBand(i,h),p=D.createEmptyBand(i,h);let f=0;for(let m=0;m<r;m++)for(let g=0;g<s;g++)e==="vector-uv"?([u[f],p[f]]=_t([c[f],o[f]],n),u[f]*=l):([u[f],p[f]]=Vt([c[f],o[f]],n),u[f]*=l,p[f]*=l),f++;const d=new D({pixelType:i,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:[u,p]});return d.updateStatistics(),d}function qe(t,e,n=1){if(n===1||!L(t))return t;const l=t.clone(),{pixels:a,width:s,height:r}=l,h=a[0],c=a[1];let o=0;for(let i=0;i<r;i++)for(let u=0;u<s;u++)e==="vector-uv"?(h[o]*=n,c[o]*=n):h[o]*=n,o++;return l.updateStatistics(),l}function Oe(t,e,n,l,a){if(H(a)||!a.spatialReference.equals(t.spatialReference))return{extent:t,width:Math.round(e/l),height:Math.round(n/l),resolution:t.width/e};const s=a.xmin,r=a.ymax,h=(t.xmax-t.xmin)/e*l,c=(t.ymax-t.ymin)/n*l,o=(h+c)/2;return t.xmin=s+Math.floor((t.xmin-s)/h)*h,t.xmax=s+Math.ceil((t.xmax-s)/h)*h,t.ymin=r+Math.floor((t.ymin-r)/c)*c,t.ymax=r+Math.ceil((t.ymax-r)/c)*c,{extent:t,width:Math.round(t.width/h),height:Math.round(t.height/c),resolution:o}}const Zt=Dt(0,0,0);function Dt(t=0,e=0,n=Math.PI,l=!0){l&&(n=(2*Math.PI-n)%(2*Math.PI));const a=l?-1:1,s=13*a,r=-7*a,h=-2*a,c=-16*a,o=21.75,[i,u]=E(0,e+s,n,o),[p,f]=E(t-5.5,e+r,n,o),[d,m]=E(t+5.5,e+r,n,o),[g,y]=E(t-1.5,e+h,n,o),[M,k]=E(t+1.5,e+h,n,o),[w,x]=E(t-1.5,e+c,n,o),[A,b]=E(t+1.5,e+c,n,o);return[i,u,p,f,g,y,M,k,d,m,w,x,A,b]}function te(t=0,e=Math.PI,n=!0){n&&(e=(2*Math.PI-e)%(2*Math.PI));const l=10,a=n?-1:1,s=5*a,r=20*a,h=25*a,c=45,o=0,i=0,u=2,p=0,f=u*a,d=n?1:-1,m=l/2*d;let[g,y]=[o+m,i-r],[M,k]=[g+u*d,y],[w,x]=[M-p*d,k+f],[A,b]=[o-m,i-h],[v,P]=[A+p*d,b-f],U=Math.ceil(t/xt),C=Math.floor(U/10);U-=8*C;const B=[],S=[];for(let K=0;K<U/2;K++,C--){C<=0&&U%2==1&&K===(U-1)/2&&(A=o,v=A+p*d,b=(b+y)/2,P=b-f);const[Q,ot]=E(A,b,e,c);if(C>0){const[it,st]=E(M,b,e,c),[lt,R]=E(g,y,e,c);B.push(it),B.push(st),B.push(Q),B.push(ot),B.push(lt),B.push(R)}else{const[it,st]=E(M,k,e,c),[lt,R]=E(w,x,e,c),[j,ut]=E(v,P,e,c);S.push(Q),S.push(ot),S.push(j),S.push(ut),S.push(lt),S.push(R),S.push(it),S.push(st)}b+=s,y+=s,k+=s,x+=s,P+=s}const[_,I]=E(o+m,i+r,e,c),T=(l/2+u)*d,[F,V]=E(o+T,i+r,e,c),[N,z]=E(o+m,i-h,e,c),[G,W]=E(o+T,i-h,e,c);return{pennants:B,barbs:S,shaft:[_,I,F,V,N,z,G,W]}}function E(t,e,n,l=1){const a=Math.sqrt(t*t+e*e)/l,s=(2*Math.PI+Math.atan2(e,t))%(2*Math.PI);return[a,(2*Math.PI+s-n)%(2*Math.PI)]}const ht=[0,1,3,6,10,16,21,27,33,40,47,55,63],ee=[0,.5,1,1.5,2],ne=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function Y(t,e,n,l){const a=wt(l||"knots",n);let s;for(s=1;s<e.length;s++)if(s===e.length-1){if(t<e[s]*a)break}else if(t<=e[s]*a)break;return Math.min(s-1,e.length-2)}function ie(t,e,n,l,a){let s=0;switch(e){case"beaufort_kn":s=Y(t,ht,"knots",n);break;case"beaufort_km":s=Y(t,ht,"kilometer-per-hour",n);break;case"beaufort_ft":s=Y(t,ht,"feet-per-second",n);break;case"beaufort_m":s=Y(t,ht,"meter-per-second",n);break;case"classified_arrow":s=Y(t,a??[],l,n);break;case"ocean_current_m":s=Y(t,ee,"meter-per-second",n);break;case"ocean_current_kn":s=Y(t,ne,"knots",n)}return s}function se(t,e){const{style:n,inputUnit:l,outputUnit:a,breakValues:s}=e,r=ct.fromJSON(l),h=ct.fromJSON(a),c=7*6,o=15;let i=0,u=0;const{width:p,height:f,mask:d}=t,m=t.pixels[0],g=t.pixels[1],y=$(d)?d.filter(x=>x>0).length:p*f,M=new Float32Array(y*c),k=new Uint32Array(o*y),w=e.invertDirection?Dt(0,0,0,!1):Zt;for(let x=0;x<f;x++)for(let A=0;A<p;A++){const b=x*p+A;if(!d||d[x*p+A]){const v=(g[b]+360)%360/180*Math.PI,P=ie(m[b],n,r,h,s);for(let C=0;C<w.length;C+=2)M[i++]=(A+.5)/p,M[i++]=(x+.5)/f,M[i++]=w[C],M[i++]=w[C+1]+v,M[i++]=P,M[i++]=m[b];const U=7*(i/c-1);k[u++]=U,k[u++]=U+1,k[u++]=U+2,k[u++]=U+0,k[u++]=U+4,k[u++]=U+3,k[u++]=U+0,k[u++]=U+2,k[u++]=U+3,k[u++]=U+2,k[u++]=U+5,k[u++]=U+3,k[u++]=U+5,k[u++]=U+6,k[u++]=U+3}}return{vertexData:M,indexData:k}}const mt=[];function le(t,e){if(mt.length===0)for(let f=0;f<30;f++)mt.push(te(5*f,0,!e.invertDirection));const n=wt(ct.fromJSON(e.inputUnit),"knots"),{width:l,height:a,mask:s}=t,r=t.pixels[0],h=t.pixels[1],c=6,o=[],i=[];let u=0,p=0;for(let f=0;f<a;f++)for(let d=0;d<l;d++){const m=f*l+d,g=r[m]*n;if((!s||s[f*l+d])&&g>=xt){const y=(h[m]+360)%360/180*Math.PI,{pennants:M,barbs:k,shaft:w}=mt[Math.min(Math.floor(g/5),29)];if(M.length+k.length===0)continue;let x=o.length/c;const A=(d+.5)/l,b=(f+.5)/a;for(let v=0;v<M.length;v+=2)o[u++]=A,o[u++]=b,o[u++]=M[v],o[u++]=M[v+1]+y,o[u++]=0,o[u++]=g;for(let v=0;v<k.length;v+=2)o[u++]=A,o[u++]=b,o[u++]=k[v],o[u++]=k[v+1]+y,o[u++]=0,o[u++]=g;for(let v=0;v<w.length;v+=2)o[u++]=A,o[u++]=b,o[u++]=w[v],o[u++]=w[v+1]+y,o[u++]=0,o[u++]=g;for(let v=0;v<M.length/6;v++)i[p++]=x,i[p++]=x+1,i[p++]=x+2,x+=3;for(let v=0;v<k.length/8;v++)i[p++]=x,i[p++]=x+1,i[p++]=x+2,i[p++]=x+1,i[p++]=x+2,i[p++]=x+3,x+=4;i[p++]=x+0,i[p++]=x+1,i[p++]=x+2,i[p++]=x+1,i[p++]=x+3,i[p++]=x+2,x+=4}}return{vertexData:new Float32Array(o),indexData:new Uint32Array(i)}}function re(t,e){let l=0,a=0;const{width:s,height:r,mask:h}=t,c=t.pixels[0],o=[],i=[],u=wt(ct.fromJSON(e.inputUnit),"knots"),p=e.style==="wind_speed"?xt:Number.MAX_VALUE;for(let f=0;f<r;f++)for(let d=0;d<s;d++){const m=c[f*s+d]*u;if((!h||h[f*s+d])&&m<p){for(let y=0;y<4;y++)o[l++]=(d+.5)/s,o[l++]=(f+.5)/r,o[l++]=y<2?-.5:.5,o[l++]=y%2==0?-.5:.5,o[l++]=0,o[l++]=m;const g=4*(l/24-1);i[a++]=g,i[a++]=g+1,i[a++]=g+2,i[a++]=g+1,i[a++]=g+2,i[a++]=g+3}}return{vertexData:new Float32Array(o),indexData:new Uint32Array(i)}}function We(t,e){return e.style==="simple_scalar"?re(t,e):e.style==="wind_speed"?le(t,e):se(t,e)}function ze(t,e,n,l=[0,0],a=.5){const{width:s,height:r,mask:h}=t,[c,o]=t.pixels,[i,u]=l,p=Math.round((s-i)/n),f=Math.round((r-u)/n),d=p*f,m=new Float32Array(d),g=new Float32Array(d),y=new Uint8Array(d),M=e==="vector-uv";for(let w=0;w<f;w++)for(let x=0;x<p;x++){let A=0;const b=w*p+x,v=Math.max(0,w*n+u),P=Math.max(0,x*n+i),U=Math.min(r,v+n),C=Math.min(s,P+n);for(let B=v;B<U;B++)for(let S=P;S<C;S++){const _=B*s+S;if(!h||h[_]){A++;const I=M?[c[_],o[_]]:[c[_],(360+o[_])%360],[T,F]=M?I:Vt(I);m[b]+=T,g[b]+=F}}if(A>=(U-v)*(C-P)*(1-a)){y[b]=1;const[B,S]=_t([m[b]/A,g[b]/A]);m[b]=B,g[b]=S}else y[b]=0,m[b]=0,g[b]=0}const k=new D({width:p,height:f,pixels:[m,g],mask:y});return k.updateStatistics(),k}const X=Z.getLogger("esri.views.2d.engine.flow.dataUtils"),oe=10;async function Je(t,e,n,l){const a=performance.now(),s=ae(e,n),r=performance.now(),h=ce(e,s,n.width,n.height),c=performance.now(),o=ue(h,!0),i=performance.now(),u=t==="Streamlines"?pe(o,oe):me(o),p=performance.now();return nt("esri-2d-profiler")&&(X.info("I.1","_createFlowFieldFromData (ms)",Math.round(r-a)),X.info("I.2","_getStreamlines (ms)",Math.round(c-r)),X.info("I.3","createAnimatedLinesData (ms)",Math.round(i-c)),X.info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(p-i)),X.info("I.5","createFlowMesh (ms)",Math.round(p-a)),X.info("I.6","Mesh size (bytes)",u.vertexData.buffer.byteLength+u.indexData.buffer.byteLength)),await Promise.resolve(),Ot(l),u}function ae(t,e){const n=fe(e.data,e.width,e.height,t.smoothing);return t.interpolate?(l,a)=>{const s=Math.floor(l),r=Math.floor(a);if(s<0||s>=e.width)return[0,0];if(r<0||r>=e.height)return[0,0];const h=l-s,c=a-r,o=s,i=r,u=s<e.width-1?s+1:s,p=r<e.height-1?r+1:r,f=n[2*(i*e.width+o)],d=n[2*(i*e.width+u)],m=n[2*(p*e.width+o)],g=n[2*(p*e.width+u)],y=n[2*(i*e.width+o)+1],M=n[2*(i*e.width+u)+1];return[(f*(1-c)+m*c)*(1-h)+(d*(1-c)+g*c)*h,(y*(1-c)+n[2*(p*e.width+o)+1]*c)*(1-h)+(M*(1-c)+n[2*(p*e.width+u)+1]*c)*h]}:(l,a)=>{const s=Math.round(l),r=Math.round(a);return s<0||s>=e.width||r<0||r>=e.height?[0,0]:[n[2*(r*e.width+s)+0],n[2*(r*e.width+s)+1]]}}function he(t,e,n,l,a,s,r,h,c){const o=[];let i=n,u=l,p=0,[f,d]=e(i,u);f*=t.velocityScale,d*=t.velocityScale;const m=Math.sqrt(f*f+d*d);let g,y;o.push({x:i,y:u,t:p,speed:m});for(let M=0;M<t.verticesPerLine;M++){let[k,w]=e(i,u);k*=t.velocityScale,w*=t.velocityScale;const x=Math.sqrt(k*k+w*w);if(x<t.minSpeedThreshold)return o;const A=k/x,b=w/x;if(i+=A*t.segmentLength,u+=b*t.segmentLength,p+=t.segmentLength/x,Math.acos(A*g+b*y)>t.maxTurnAngle)return o;if(t.collisions){const v=Math.round(i*c),P=Math.round(u*c);if(v<0||v>r-1||P<0||P>h-1)return o;const U=s[P*r+v];if(U!==-1&&U!==a)return o;s[P*r+v]=a}o.push({x:i,y:u,t:p,speed:x}),g=A,y=b}return o}function ce(t,e,n,l){const a=[],s=new It,r=1/Math.max(t.lineCollisionWidth,1),h=Math.round(n*r),c=Math.round(l*r),o=new Int32Array(h*c);for(let u=0;u<o.length;u++)o[u]=-1;const i=[];for(let u=0;u<l;u+=t.lineSpacing)for(let p=0;p<n;p+=t.lineSpacing)i.push({x:p,y:u,sort:s.getFloat()});i.sort((u,p)=>u.sort-p.sort);for(const{x:u,y:p}of i)if(s.getFloat()<t.density){const f=he(t,e,u,p,a.length,o,h,c,r);if(f.length<2)continue;a.push(f)}return a}function fe(t,e,n,l){if(l===0)return t;const a=Math.round(3*l),s=new Array(2*a+1);let r=0;for(let o=-a;o<=a;o++){const i=Math.exp(-o*o/(l*l));s[o+a]=i,r+=i}for(let o=-a;o<=a;o++)s[o+a]/=r;const h=new Float32Array(t.length);for(let o=0;o<n;o++)for(let i=0;i<e;i++){let u=0,p=0;for(let f=-a;f<=a;f++){if(i+f<0||i+f>=e)continue;const d=s[f+a];u+=d*t[2*(o*e+(i+f))+0],p+=d*t[2*(o*e+(i+f))+1]}h[2*(o*e+i)+0]=u,h[2*(o*e+i)+1]=p}const c=new Float32Array(t.length);for(let o=0;o<e;o++)for(let i=0;i<n;i++){let u=0,p=0;for(let f=-a;f<=a;f++){if(i+f<0||i+f>=n)continue;const d=s[f+a];u+=d*h[2*((i+f)*e+o)+0],p+=d*h[2*((i+f)*e+o)+1]}c[2*(i*e+o)+0]=u,c[2*(i*e+o)+1]=p}return c}function ue(t,e){const n=new It,l=t.reduce((c,o)=>c+o.length,0),a=new Float32Array(4*l),s=new Array(t.length);let r=0,h=0;for(const c of t){const o=r;for(const i of c)a[4*r+0]=i.x,a[4*r+1]=i.y,a[4*r+2]=i.t,a[4*r+3]=i.speed,r++;s[h++]={startVertex:o,numberOfVertices:c.length,totalTime:c[c.length-1].t,timeSeed:e?n.getFloat():0}}return{lineVertices:a,lineDescriptors:s}}function pe(t,e){const{lineVertices:l,lineDescriptors:a}=t;let s=0,r=0;for(const f of a)s+=2*f.numberOfVertices,r+=6*(f.numberOfVertices-1);const h=new Float32Array(s*9),c=new Uint32Array(r);let o=0,i=0;function u(){c[i++]=o-2,c[i++]=o,c[i++]=o-1,c[i++]=o,c[i++]=o+1,c[i++]=o-1}function p(f,d,m,g,y,M,k,w){const x=o*9;let A=0;h[x+A++]=f,h[x+A++]=d,h[x+A++]=1,h[x+A++]=m,h[x+A++]=M,h[x+A++]=k,h[x+A++]=g/2,h[x+A++]=y/2,h[x+A++]=w,o++,h[x+A++]=f,h[x+A++]=d,h[x+A++]=-1,h[x+A++]=m,h[x+A++]=M,h[x+A++]=k,h[x+A++]=-g/2,h[x+A++]=-y/2,h[x+A++]=w,o++}for(const f of a){const{totalTime:d,timeSeed:m}=f;let g=null,y=null,M=null,k=null,w=null,x=null;for(let A=0;A<f.numberOfVertices;A++){const b=l[4*(f.startVertex+A)+0],v=l[4*(f.startVertex+A)+1],P=l[4*(f.startVertex+A)+2],U=l[4*(f.startVertex+A)+3];let C=null,B=null,S=null,_=null;if(A>0){C=b-g,B=v-y;const I=Math.sqrt(C*C+B*B);if(C/=I,B/=I,A>1){let T=C+w,F=B+x;const V=Math.sqrt(T*T+F*F);T/=V,F/=V;const N=Math.min(1/(T*C+F*B),e);T*=N,F*=N,S=-F,_=T}else S=-B,_=C;S!==null&&_!==null&&(p(g,y,M,S,_,d,m,U),u())}g=b,y=v,M=P,w=C,x=B,k=U}p(g,y,M,-x,w,d,m,k)}return{vertexData:h,indexData:c}}function me(t){const{lineVertices:a,lineDescriptors:s}=t;let r=0,h=0;for(const I of s){const T=I.numberOfVertices-1;r+=4*T*2,h+=6*T*2}const c=new Float32Array(r*16),o=new Uint32Array(h);let i,u,p,f,d,m,g,y,M,k,w,x,A,b,v=0,P=0;function U(){o[P++]=v-8,o[P++]=v-7,o[P++]=v-6,o[P++]=v-7,o[P++]=v-5,o[P++]=v-6,o[P++]=v-4,o[P++]=v-3,o[P++]=v-2,o[P++]=v-3,o[P++]=v-1,o[P++]=v-2}function C(I,T,F,V,N,z,G,W,K,Q,ot,it,st,lt){const R=v*16;let j=0;for(const ut of[1,2])for(const Rt of[1,2,3,4])c[R+j++]=I,c[R+j++]=T,c[R+j++]=F,c[R+j++]=V,c[R+j++]=G,c[R+j++]=W,c[R+j++]=K,c[R+j++]=Q,c[R+j++]=ut,c[R+j++]=Rt,c[R+j++]=st,c[R+j++]=lt,c[R+j++]=N/2,c[R+j++]=z/2,c[R+j++]=ot/2,c[R+j++]=it/2,v++}function B(I,T){let F=M+w,V=k+x;const N=Math.sqrt(F*F+V*V);F/=N,V/=N;const z=M*F+k*V;F/=z,V/=z;let G=w+A,W=x+b;const K=Math.sqrt(G*G+W*W);G/=K,W/=K;const Q=w*G+x*W;G/=Q,W/=Q,C(i,u,p,f,-V,F,d,m,g,y,-W,G,I,T),U()}function S(I,T,F,V,N,z){if(M=w,k=x,w=A,x=b,M==null&&k==null&&(M=w,k=x),d!=null&&m!=null){A=I-d,b=T-m;const G=Math.sqrt(A*A+b*b);A/=G,b/=G}M!=null&&k!=null&&B(N,z),i=d,u=m,p=g,f=y,d=I,m=T,g=F,y=V}function _(I,T){M=w,k=x,w=A,x=b,M==null&&k==null&&(M=w,k=x),M!=null&&k!=null&&B(I,T)}for(const I of s){i=null,u=null,p=null,f=null,d=null,m=null,g=null,y=null,M=null,k=null,w=null,x=null,A=null,b=null;const{totalTime:T,timeSeed:F}=I;for(let V=0;V<I.numberOfVertices;V++)S(a[4*(I.startVertex+V)+0],a[4*(I.startVertex+V)+1],a[4*(I.startVertex+V)+2],a[4*(I.startVertex+V)+3],T,F);_(T,F)}return{vertexData:c,indexData:o}}function Ut(t,e){const n=e.pixels,{width:l,height:a}=e,s=new Float32Array(l*a*2),r=e.mask||new Uint8Array(l*a*2);if(e.mask||r.fill(255),t==="vector-uv")for(let h=0;h<l*a;h++)s[2*h+0]=n[0][h],s[2*h+1]=-n[1][h];else if(t==="vector-magdir")for(let h=0;h<l*a;h++){const c=n[0][h],o=qt(n[1][h]),i=Math.cos(o-Math.PI/2),u=Math.sin(o-Math.PI/2);s[2*h+0]=i*c,s[2*h+1]=u*c}return{data:s,mask:r,width:l,height:a}}async function Xe(t,e,n,l,a,s){const r=performance.now(),h=Wt(e.spatialReference);if(!h){const w=await Tt(t,e,n,l,a,s);return nt("esri-2d-profiler")&&X.info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-r)),nt("esri-2d-profiler")&&X.info("I.9","Number of parts",1),w}const[c,o]=h.valid,i=o-c,u=Math.ceil(e.width/i),p=e.width/u,f=Math.round(n/u);let d=e.xmin;const m=[],g=performance.now();for(let w=0;w<u;w++){const x=new zt({xmin:d,xmax:d+p,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});m.push(Tt(t,x,f,l,a,s)),d+=p}const y=await Promise.all(m);nt("esri-2d-profiler")&&X.info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-g)),nt("esri-2d-profiler")&&X.info("I.9","Number of parts",y.length);const M={data:new Float32Array(n*l*2),mask:new Uint8Array(n*l),width:n,height:l};let k=0;for(const w of y){for(let x=0;x<w.height;x++)for(let A=0;A<w.width;A++)k+A>=n||(M.data[2*(x*n+k+A)+0]=w.data[2*(x*w.width+A)+0],M.data[2*(x*n+k+A)+1]=w.data[2*(x*w.width+A)+1],M.mask[x*n+k+A]=w.mask[x*w.width+A]);k+=w.width}return nt("esri-2d-profiler")&&X.info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-r)),M}async function Tt(t,e,n,l,a,s){const r={requestProjectedLocalDirections:!0,signal:s};if($(a)&&(r.timeExtent=a),t.type==="imagery"){await t.load({signal:s});const o=t.rasterInfo.dataType,i=await t.fetchImage(e,n,l,r);return!i||H(i.pixelData)||H(i.pixelData.pixelBlock)?{data:new Float32Array(n*l*2),mask:new Uint8Array(n*l),width:n,height:l}:Ut(o,i.pixelData.pixelBlock)}await t.load({signal:s});const h=t.rasterInfo.dataType,c=await t.fetchPixels(e,n,l,r);return!c||H(c.pixelBlock)?{data:new Float32Array(n*l*2),mask:new Uint8Array(n*l),width:n,height:l}:Ut(h,c.pixelBlock)}export{Re as A,qe as B,re as D,We as F,De as M,je as R,Le as S,$e as T,Xe as a,D as b,Xt as c,Pt as d,Ne as e,Ee as f,Je as g,Te as h,L as i,ze as j,Fe as k,Be as l,Ge as m,Ie as n,kt as o,Ce as p,Ve as q,Ue as r,Mt as s,Bt as t,Se as u,_e as v,_t as w,Oe as x,ct as y,wt as z};
