import{s as F,b as W,a as _}from"./Error-781981d1.js";import{t as B,r as E}from"./typedArrayUtil-74bbfd45.js";import{m as J,v as O}from"./Polyline-40b9e769.js";import{r as U,o as b,i as R,s as k}from"./normalizeUtilsCommon-04cad10b.js";import{d as X,R as I,q as G}from"./Extent-8fae2379.js";import"./geometry-0d19f94b.js";import{U as C,L as H}from"./request-b4e08038.js";import{c as D,v as K}from"./jsonUtils-15ca15d7.js";import{f as Q}from"./utils-14667ccd.js";import{r as V,o as Y}from"./utils-067ee6bc.js";async function Z(t,s,f,n){const e=Q(t),c=s[0].spatialReference,l={...n,query:{...e.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:D(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await C(e.path+"/cut",l),{cutIndexes:p,geometries:m=[]}=o.data;return{cutIndexes:p,geometries:m.map(h=>{const x=K(h);return x.spatialReference=c,x})}}async function tt(t,s,f){const n=typeof t=="string"?H(t):t,e=s[0].spatialReference,c=D(s[0]),l={...f,query:{...n.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(V(s))}},{data:o}=await C(n.path+"/simplify",l);return Y(o.geometries,c,e)}const T=F.getLogger("esri.geometry.support.normalizeUtils");function et(t){return t.type==="polygon"}function st(t){return t[0].type==="polygon"}function nt(t){return t[0].type==="polyline"}function ot(t,s){if(!(t instanceof J||t instanceof O)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw T.error(e),new _(e)}const f=b(t),n=[];for(const e of f){const c=[];n.push(c),c.push([e[0][0],e[0][1]]);for(let l=0;l<e.length-1;l++){const o=e[l][0],p=e[l][1],m=e[l+1][0],h=e[l+1][1],x=Math.sqrt((m-o)*(m-o)+(h-p)*(h-p)),a=(h-p)/x,y=(m-o)/x,u=x/s;if(u>1){for(let q=1;q<=u-1;q++){const v=q*s,r=y*v+o,i=a*v+p;c.push([r,i])}const $=(x+Math.floor(u-1)*s)/2,S=y*$+o,j=a*$+p;c.push([S,j])}c.push([m,h])}}return et(t)?new O({rings:n,spatialReference:t.spatialReference}):new J({paths:n,spatialReference:t.spatialReference})}function P(t,s,f){if(s){const n=ot(t,1e6);t=G(n,!0)}return f&&(t=k(t,f)),t}function z(t,s,f){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<f){const e=R(n,f);t[0]=n+e*(-2*f)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<f){const e=R(n,f);t=t.clone().offset(e*(-2*f),0)}}return t}function rt(t,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],c=s.geometries[n],l=b(c);for(let o=0;o<l.length;o++){const p=l[o];p.some(m=>{if(m[0]<180)return!0;{let h=0;for(let a=0;a<p.length;a++){const y=p[a][0];h=y>h?y:h}h=Number(h.toFixed(9));const x=-360*R(h,180);for(let a=0;a<p.length;a++){const y=c.getPoint(o,a);c.setPoint(o,a,y.clone().offset(x,0))}return!0}})}if(e===f){if(st(t))for(const o of b(c))t[e]=t[e].addRing(o);else if(nt(t))for(const o of b(c))t[e]=t[e].addPath(o)}else f=e,t[e]=c}return t}async function it(t,s,f){if(!Array.isArray(t))return it([t],s);s&&typeof s!="string"&&T.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??W.geometryServiceUrl;let e,c,l,o,p,m,h,x,a=0;const y=[],u=[];for(const r of t)if(B(r))u.push(r);else if(e||(e=r.spatialReference,c=X(e),l=e.isWebMercator,m=l?102100:4326,o=U[m].maxX,p=U[m].minX,h=U[m].plus180Line,x=U[m].minus180Line),c)if(r.type==="mesh")u.push(r);else if(r.type==="point")u.push(z(r.clone(),o,p));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(g=>z(g,o,p)),u.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);u.push(i.rings?new O(i):i)}else if(r.extent){const i=r.extent,g=R(i.xmin,p)*(2*o);let d=g===0?r.clone():k(r.clone(),g);i.offset(g,0),i.intersects(h)&&i.xmax!==o?(a=i.xmax>a?i.xmax:a,d=P(d,l),y.push(d),u.push("cut")):i.intersects(x)&&i.xmin!==p?(a=i.xmax*(2*o)>a?i.xmax*(2*o):a,d=P(d,l,360),y.push(d),u.push("cut")):u.push(d)}else u.push(r.clone());else u.push(r);let $=R(a,o),S=-90;const j=$,q=new J;for(;$>0;){const r=360*$-180;q.addPath([[r,S],[r,-1*S]]),S*=-1,$--}if(y.length>0&&j>0){const r=rt(y,await Z(n,y,q,f)),i=[],g=[];for(let w=0;w<u.length;w++){const L=u[w];if(L!=="cut")g.push(L);else{const N=r.shift(),M=t[w];E(M)&&M.type==="polygon"&&M.rings&&M.rings.length>1&&N.rings.length>=M.rings.length?(i.push(N),g.push("simplify")):g.push(l?I(N):N)}}if(!i.length)return g;const d=await tt(n,i,f),A=[];for(let w=0;w<g.length;w++){const L=g[w];L!=="simplify"?A.push(L):A.push(l?I(d.shift()):d.shift())}return A}const v=[];for(let r=0;r<u.length;r++){const i=u[r];if(i!=="cut")v.push(i);else{const g=y.shift();v.push(l===!0?I(g):g)}}return v}function xt(t,s){const f=X(s);if(f){const[n,e]=f.valid,c=e-n;if(t<n)for(;t<n;)t+=c;if(t>e)for(;t>e;)t-=c}return t}export{xt as U,it as v};
